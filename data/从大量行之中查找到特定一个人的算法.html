<!DOCTYPE html>
<html>
<head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>从大量行之中查找到一个人的算法</title>
</head>
<body>
    <blockquote>
        <p>最初的题目是首先提供大约一万行用户信息,输入一个用户名，然后找到这个人的信息，
        </p>
        <p>
            我想的就是根据每个名字每个字对应的字符集编码值进行排序，然后在所有的排序姓名里面进行logn级别的查找，10000的数字，需要13-14次查找
        </p>
        <p>
            然后增加难度的问题是用户名非常长，对比的时候非常消耗资源，然后怎么处理
        </p>
        <p>
            当时太不谨慎，立即就爆出来hash table ，time33算法就是为了解决字符串到int数组的转化的，这个想法是好的，但是不应该提及hash table ，自己虽然明白拉链法解决hash表，但是毕竟hash table不是自己擅长的领域
            ，通过times33 算法转换之后，对转换的int序列进行排序，查找的时候，依旧可以logn级别的查找，但是在找到具体位置之后，需要在相同数值的进行比较，只是说，这种比较一般不会很多
        </p>
        <blockquote>
            <p>
                面试官对这个答案依旧不满意，说对全体人员的排序会相当消耗资源，当时没有解决方案，睡了一觉，感觉可以做的更加优化一点。
            </p>
            <p>
                第一步依旧是times33的转化，将目标字符串转化为int，然后从头开始遍历数据，边转化边进行整理，将转化之后的数据保存在红黑树之中，当查找到想要的用户之后，停止整理，返回信息。
                在以后的查找里面，可以首先对目标字符串进行，然后在红黑树里面查找，logn级别的查找，如果可以寻找到想要的数据，就返回信息，如果不可以找到，就接着上一次没有整理完的行接着进行转化整理。
                对于转化之后重复的情况，依旧是通过拉链法解决冲突。
            </p>
            <p>
                整体复杂度为m * log(n)+ O(n) * log(n)的，m为查询次数 , 虽然整体复杂度和上一次的没有什么大的变化，但是这次将数据的处理分为几次，对于服务器来说，压力更小一点，而且，在查询次数比较少的情况，未必就处理全体数据
            </p>
        </blockquote>
    </blockquote>
</body>
</html>
