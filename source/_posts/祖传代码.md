---
title: 祖传代码
date: 2019-09-28 18:47:48
tags:
---

这是一份可以传给我孙子的代码，记录了libevent事件调度和socket网络编程中端口监听的部分

```
#include<iostream>
#include<unordered_map>
#include<functional>
#ifndef RPC_FRAMEWORK_HEAD
#define RPC_FRAMEWORK_HEAD
#include "rpc_framework.h"
#endif


struct HttpServiceHandler {
    ServiceConfig serviceConfig;
    std::unordered_map<std::string, std::function<void(std::string &, ServiceConfig &, std::string &, std::vector<uint8_t> *, HttpResponse *)>> actionMap;
}

struct HttpServerData {
    std::unordered_map<ServiceConfig, HttpServiceHandler> *serviceHandlermap;
    std::string *httpContext;
}

class TransferServer
{
    public:
        virtual void start()=0;
        virtual void stop()=0;
        template<typename T, typename... Args>

        void addMethod(MethodInvoker<T, Args...> &methodInvoker) {

        }

        template<typename T>

        void addMethod(MethodInvoker<T, void> &methodInvoker) {

        }
}

class HttpTransferServer : public TransferServer
{
    public:
        HttpTransferServer(int serverPort): serverPort(serverPort){};
        HttpTransferServer(int serverPort, const std::string &httpContext): serverPort(serverPort), httpContext(httpContext) {};
        /**
         * 析构函数
         */
        ~HttpTransferServer() {
            // evhttp_free(http)
            // event_base_free(base)
        }


    int bindSocket() {
        int r;
        int nfd;

        nfd = socket(AF_INET, SOCK_STREAM, 0);
        if (nfd < 0) {
            return -1;
        }
        int one = 1;
        r = setsocket(nfd, SOL_SOCKET, SO_REUSEDADDR, (char *)&one, sizeof(int));

        struct sockaddr_in addr;
        memset(&addr, 0, sizeof(addr));

        addr.sin_family = AF_INET;
        addr.sin_adrr.s_addr = INADDR_ANY;
        addr.sin_port = htons(servrPort);

        r = bind(nfd, (struct sockaddr*)&addr, sizeof(addr));
        if (r < 0) {
            return -1;
        }
        r = listen(nfd, 10240);
        if (r < 0) {
            return -1;
        }
        int flags;
        if ((flags = fcntl(nfd, F_GETFL, 0)) < 0 || fcntl(nfd, F_SETFL, flags | O_NONBLOCK) < 0) {
            return -1;
        }
        return nfd;
    }

    void start() override {
        int nfd = bindSocket;
        if (nfd < 0) {
            exit(1);
        }

        HttpServerData httpServerData;
        httpServerData.serviceHandlermap=&serviceHandlerMap_;
        httpserverData.httpContext=&httpContext;
        int threads = std::thread::hardware_concurrency() * 2;
        struct event_base *base_arr[threads];
        baseGroup = base_arr;

        for (int i = 0; i < threads; i++) {
            std::thread t([&]() {
                struct event_base &base = event_init();
                base_arr[i] = base;
                if (base == NULL) {
                    exit(1);
                }
                struct evhttp *httpd = evhttp_new(base);
                if (httpd == NULL) {
                    exit(1);
                }
                evhttp_accept_socket(httpd, nfd);
                evhttp_set_gencb(httpd, HttpServicehandler_Impl::service_request_cb, (void *)&httpServerData);
                event_base_dispatch(base);
            });
            if (i < (threads - 1)) {
                t.deatch();
            } else {
                t.join();
            }
        }
    }

    void stop() override {
        while (baseGroup != NULL) {
            event_base_loopbreak(*baseGroup);
            baseGroup++;
        }

        delete this;
    }

    private:
        std::unordered_map<ServiceConfig, HttpServiceHandler> serviceHandlerMap_;
        struct event_base **baseGroup;
        int serverPort;
        std::string httpContext;
}
```